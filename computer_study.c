#include <stdio.h>
#include <stdlib.h> 
#include <conio.h>

void good(){
	getch(); 
	system("cls");
}
int main(){
	int n,nn,nnn,chapter,N,pn;
	intro:
	printf("단원을 고르세요.\n1.변수\n2.함수\n3.배열\n4.단원 고르기\n");
	scanf("%d", &chapter);
	if(chapter==1){
		start:
			printf("1.함수 정의\n2.변수 정의\n3.변수의 속성\n4.변수의 범위\n5.지역변수의 초기값\n6.매개변수\n7.전역변수\n8.지역변수와 전역변수\n9.정적 할당과 자동할당\n10.저장 유형 지정자\n11.가변매개변수 \n12.단운고르기\n");
			scanf("%d",&n);
		
			if(n==1){
				printf("정의가 중요하다.\n함수:모듈화 프로그래밍을 위한 구문구조\n유지 보수가 좋다. 직관성이 좋다. 가독성이 좋다. 재사용성이 좋다.\n");
				good();
				goto start; 
			}
			if(n==2){
				printf("메모리는 다수의 셀들로 구성되고 셀은 다양한 주소로 구성되어 있다. \n주소는 외우기 힘드니까 대신 변수를 사용하는 것이다. \n변수는 값을 저장하기 위한 공간!이다. \n나중에 쓰기 위해 저장해놓는 것이다. \n");
				good(); 
				goto start;
			}
			if(n==3){
				printf("변수의 속성: 이름, 타입(자료형), 크기, 값 + 범위, 생존시간, 연결\n 이것들을 가지고 변수를 구분지을 수 있다.\n1.범위: 변수가 사용 가능한 범위, 가시성 \n2.생존시간: 메모리에 존재하는 시간 \n3.연결: 다른 영역에 있는 변수와의 연결상태\n");
				printf("프로그램- 변수를 생성하고 소멸시킨다.\nOS-공간을 할당하고 반환한다.\n반환하지 않으면 공간이 모자르다.\n");
				good();
				goto start;
			} 
			if(n==4){
				printf("변수의 범위-1. 전역변수 2. 지역변수\n함수의 외부에서 정의하면 전역변수, 함수의 내부에서 정의하면 지역변수이다.\n지역변수는 선언하는 위치가 다르면 이름이 같을 수 있다. \n");
				printf("지역을 벗어나면 변수가 소멸되고 OS는 다시 공간을 반환하기 때문에 지역변수의 생존시간은 블록이 시작할 때부터 끝날때 까지만이다. \n자동적으로 소멸된다. ");
				good(); 
				goto start;
			}
			if(n==5){
				printf("지역변수가 블록안에서 정의되고 값을 넣어주면 계속 초기화된다.\n지역변수는 쓰레기값이 저장되어 있지만 전역변수는 0으로 초기화해준다. \n");
				good();
				goto start;
			}
			if(n==6){
				printf("매개변수는 유일하게 블록 밖에서 선언했지만 지역변수이다.\n매개변수는 값에의한호출 이라고한다. call by value\n");
				good(); 
				goto start;
			} 
			if(n==7){
				printf("전역변수는 잘못쓰면 논리적 오류가 생길수 있다. 전역변수는 모든 곳에서 같은 변수이다.\n따라서 코드를 짠 사람이 흐름을 완벽히 이해하고 있어야 하며 논리적오류를 하나 막아주기 위해 0으로 초기화 해주는 것이다. \n");
				good();
				goto start; 
			}
			if(n==8){
				printf("전역변수와 지역변수가 있으면 구간이 좁은 지역변수가 먼저이다. \n");
				good();
				goto start; 
			} 
			if(n==9){
				printf("정적할당: 프로그램 실행시간동안 계속유지\n자동할당:블록에 들어갈때 생성, 블록에서 나올때 소멸\n생존기간을 결정하는 요인: 변수 선언위치, 저장 유형 지정자\n");
				good();
				goto start;
			}
			if(n==10){
				middle:
					printf("1.auto\n2.static\n3.register\n4.extern\n");
					scanf("%d",&nn);
					if(nn==1){
						printf("<auto>\n지역 변수는 auto가 생략되어도 자동 변수가 된다.(자동 지역변수)");
						good();
						goto middle; 
					}
					else if(nn==2){
						printf("<static>\n 공간이 고정적이다. 그러므로 그 지역을 빠져나갔어도 그 값이 보존된다.\n이게 필요한 이유. 로그인 횟수 제한\n수명을 전역변수처럼 늘린 것이다.\n범위는 지역변수로 쓰는데 수명은 전역변수처럼 사용하기위해 사용한다.\n "); 
						good();
						goto middle;
					}
					else if(nn==3){
						printf("<register>\nCPU내부에 RAM보다 빠른 저장공간이 있다.\n변수가 갖고 있는 공간은 주기억장치의 공간이다. 그래서 공간을 레지스터에 만들면 속도가 빨라질 것이다.\n");
						printf("RAM의 read/write속도가 느린것이기 때문에 read/write가 많은 것을 레지스터변수로 설정해야 한다. \n너무 많은 레지스터변수를 지정하면 운영체제가 알아서 메모리변수로 바꿔준다.\n"); 
						good();
						goto middle;
					}
					else if(nn==4){
						printf("<extern>\n이것을 통해 연결을 한다. extern을 이용하여 외부연결을 한다. ");
						good();
						goto middle;
					} 
					else{
						system("cls");
						goto start;
					}
			}
			if(n==11){
				printf("가변매개변수는 처음에 매개변수의 개수를 모를때 ...으로 해서 한다. 괄호안에 첫번째수는 매개변수의 개수를 말한다. \n");
				good();
				goto start;
			}
			if(n==12){
				system("cls");
				goto intro;
			}
	}
	if(chapter==2){
		start1:
			printf("1.재귀함수\n2.재귀함수가 필요한것\n3.순환호출의 비효율성\n4.재귀함수 만들기\n5.재귀함수의 원리\n6.재귀함수의 장점\n7.재귀함수의 단점\n8.단원고르기\n");
			scanf("%d", &nnn);
			if(nnn==1){
				printf("재귀함수는 호출하는 함수와 호출되는 함수가 같다. \n자기자신을 다시 호출하는 것이다.\n");
				printf("GNU is Not Unix. 단체이름을 재귀적으로 만든 것이다.\nSADA도 재귀적으로 만들어졌데..\n재귀적으로 만들면 알고리즘이 그대로 코드로 만들 수 있다.\n ");
				printf("반복문없이 반복을 한다. 재귀적으로 표현하면 알고리즘이 그대로 코드가 되어서 직관적으로 알수 있다. \n"); 
				good();
				goto start1;
			}
			if(nnn==2){
				printf("순환 호출을 하는 부분과 순환 호출을 멈추는 부분이 있어야 한다.\n재귀함수는 알고리즘만 맞으면 코딩이 쉽기때문에 알고리즘을 잘 짜야한다.\n");
				good();
				goto start1;
			}
			if(nnn==3){
				printf("중복이 발생해서 비효율적이다. 그러나 메모를 해놓으면 된다.\n");
				good();
				goto start1; 
			}
			if(nnn==4){
				printf("1.함수정의: 함수의 원형과 의미를 정하는 것\n2.초항설계: 함수의 계산이 가장 간단한 인수의 상황(초항은 여러개일수가 있다.)\n");
				printf("3.관계식 설계: 일반항과 전항 사이의 관계식을 만들어야 한다. \n");
				good();
				goto start1;
			} 
			if(nnn==5){
				printf("재귀함수를 사용하려면 순서대로 들어간후 역순으로 나와야 한다. \n");
				printf("그 프로그램의 명령이나 데이터가 램에 들어가야하는데 할당된 공간을 넘어서서 프로세스상태가 안되어서 프로그램이 종료된 것이다. \n");
				printf("자료형의 오버플로우는 32비트를 넘어서는게 잘려나가는 것이고 여기서 오버플로우는 공간보다 큰 용량이 램에 들어가려다 공간이 모자라서 들어가지 못할 때 나타난다.\n"); 
				good();
				goto start1; 
			} 
			if(nnn==6){
				printf("메모이제이션 등과 결합하여 효율높은 알고리즘 설계가능\n"); 
				printf("변수나 반복문 없이 반복 구현할 수 있으므로 코드가 간결함.\n메모이제이션 등과 결합하여 효율 높은 알고리즘 설계 가능");
				good();
				goto start1;
			} 
			if(nnn==7){
				printf("스택오버플로우 발생\n함수 호출에 따른 추가시간이 발생하므로 속도가 느리다. \n");
				printf("중복계산 발생이 가능하므로 시간이 매우 느려질 수 있다. \n");
				good();
				goto start1;
			}
			if(nnn==8){
				printf("함수정의:void f(int n) 정수 n을 2진수로 바꾸어 출력\n초항:0일때. f(0)일때 아무것도 안한다. \n");
				printf("관계식(n>0): f(n/2);, printf(n%2);"); 
			}
			if(nnn==9){
				system("cls");
				goto intro;
			}
	}
	if(chapter==3){
		start2:
			printf("1.배열의 시작\n2.배열의 선언\n3.배열의 장점\n4.배열의 위험성\n5.배열의 초기화\n6.배열의 복사\n7.배열과 매개변수\n8.속도\n9.단원고르기\n");
			scanf("%d", &N);
			if(N==1){
				printf("배열을 사용하면 한번에 여러개의 값을 저장할 수 있는 공간을 할당받을 수 있다. \n");
				printf("개별 변수를 사용하려면 10개필요하면 변수는 10개를 선언하고, 값을 넣어야 하는데 배열을 사용하면 훨씬 효율적이다. \n");
				printf("배열은 변수인데 자료형과 이름이 같아야 한다. \n그리고 이름과 자료형이 같은 변수들의 집합을 배열이라고 한다. \n");
				printf("배열은 메모리상에서 저장공간이 일렬로 붙어있다. \n배열을 구분하기위해 이름뒤에 인덱스(첨자)를 붙여준다. \n");
				good();
				goto start2;
			}
			if(N==2){
				printf("int grade[10];\n자료형  배열이름 배열크기\n");
				good();
				goto start2; 
			}
			if(N==3){
				printf("반복문과 결합하면 배열의 값을 쉽게 읽어들일수 있다.\n");
				good();
				goto start2;
			}
			if(N==4){
				printf("배열을 n개 만들었을 때 배열[n]에 어떤 값을 넣을 수 있다. 왜냐하면 주소값이 일정하게 늘어나기 때문이다. \n");
				printf("그런데 운영체제한테 미리 그곳을 사용한다고 안했기 때문에 다른 프로세스가 사용중인 곳일수도 있다. \n");
				printf("따라서 치명적인 오류가 발생할 수 있다. \n");
				good();
				goto start2; 
			}
			if(N==5){
				printf("배열은 중괄호로 초기화한다. \n");
				printf("그리고 중괄호가 끝나면 세미콜론을 붙여준다.\n초기화를 할때 배열개수보다 적게 초기화하면 나머지는 다 0으로 초기화 된다. \n"); 
				good();
				goto start2; 
			}
			if(N==6){
				printf("배열을 복사하려면 이름을 복사하면 안돼고 반복문을 이용해서 하나씩 복사해야 된다.");
				printf("비교도 이름만 갖고 하면 안돼고 반복문을 이용해야한다.\n");
				good();
				goto start2; 
			}
			if(N==7){
				printf("배열을 함수의 인수로 전달해줄 때는 이름을 쓴다.\n매개변수선언시 자료형앞에 const를 붙이면 값을 바꿀수 없다. \n");
				printf("배열을 함수에 전달할 때는 이름을 보내고(call by reference, 참조에 의한 호출) 받을 때는 원본 배열로 받는다. ");
				good();
				goto start2;
			}
			if(N==8){
				printf("선택정렬은 대략 n^2번을 실행해야한다. 요즘은 nlogn만큼이 제일 빠르다. \n");
				good();
				goto start2;
			}
			if(N==9){
				system("cls");
				goto intro;
			}
	}
	if(chapter==4){
		startp:
			printf("1.포인터\n2.포인터의 기본\n3.포인터를 쓰는이유\n");
			scanf("%d", &pn);
			if(pn==1){
				printf("포인터는 변수이다.\n 포인터는 기본적으로 unsigned int형으로 주소를 표시하는 방식이다.\n");
				printf("변수앞에 &를 붙이면 변수의 주소를 알려준다. \n대표주소는 가장 앞에있는 것이다. \n");
				printf("포인터 선언할때는 이름앞에*을 넣어준다.");
				good();
				goto startp;
			}
			if(pn==2){
				printf("변수는 공간이 다양하지만 포인터변수는 주소를 처리하기 때문에 다 4바이트이다. \n");
				printf("포인터 앞의 자료형은 주소를 통해 접근해야 하는 공간의 주소가 몇개인지를 알려주는 것이다.\n");
				printf("포인터변수앞에 별은 포인터변수라는 것을 알려주지만 그 외의 별은 주소가 가리키는 곳의 내용을 반환하라는 뜻이다.\n");
				good();
				goto startp; 
			}
			if(pn==3){
				printf("같은 공간에 접근할 수 있는 변수가 여러개가 존재하게 된다.\n배열처럼 포인터도 접근이 쉽고 반복문과 결합도 쉽다.\n");
				printf("이름도 비슷해서 사용하기도 편리하다.\n주소를 갖고있어서 공간에 접근하기도 쉽다.\n"); 
			}
			if(pn==4){
				printf("포인터에 증감연산자를 하면 포인터 타입의 크기만큼 증감을 한다.\n포인터까리는 곱하거나 나누면 안됨.\n");
				printf("덧셈뺄셈은 된다. \n주소를 이용한 연산일땐 상대적 거리이다. \n배열의 이름은 포인터변수이다.\n");
			} 
	} 
	return 0;
}























